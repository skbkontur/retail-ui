import { Canvas } from '@storybook/blocks';
import * as DocsStories from './Dependent.docs.stories.tsx';
import { Meta } from '../../../../.storybook/Meta';

<Meta of={DocsStories} />

# Зависимые валидации

По-умолчанию все валидации зависимые, согласно [Гайду](https://guides.kontur.ru/principles/validation/#33).
Это обеспечивается не только предоставлением доступа к модели `root` (см. ниже).
Также, потеря фокуса у любого поля вызывает валидации у полей с типом `lostfocus` (см. [независимые валидации](#/independent-validation)).

Валидация поля может зависить от значений других полей модели.
Например, значение `value` должно состоять только из цифр, если флаг `onlyDigits` установлен в значение `true`.

```jsx static
    interface Data {
      onlyDigits: boolean;
      value: string;
    }

    const validate = createValidator<Data>((b, root) => {
      b.prop(x => x.value, b => {
        b.invalid(x => root.onlyDigits && !/^\d*$/.test(x), "Только цифры");
      });
    });
```

Вторым аргументом правила валидации узла можно получить значение узла.

```jsx static
const validate =
  createValidator <
  Data >
  ((b, root) => {
    b.prop(
      (x) => x.value,
      (b, v) => {
        //...
      },
    );
  });
```

Так в аргументе `root` будет вся модель, а в аргументе `v` значение узла `value`.
Значения аргументов `root` и `v` можно использовать в критерии валидации, для формирования текста ошибки и для вычисления типа валидации.
Аналогично в правиле конфигурирования элемента массива можно получить значение текущего элемента, его индекс и сам массив.

```jsx static
    const validate = createValidator<string[]>(b => {
      b.array(x => x, (b, value, index, array) => {
        //...
      });
    });
```

### Пример

<Canvas of={DocsStories.Dependent} />

```jsx static
import React from 'react';
import { Input } from '@skbkontur/react-ui/components/Input';
import { Toggle } from '@skbkontur/react-ui/components/Toggle';

import { ValidationContainer, ValidationWrapper, createValidator } from '../../../../src';
import { Form } from '../../../Common/Form';

interface Data {
  onlyDigits: boolean;
  value: string;
}

const validate = createValidator<Data>((b, root) => {
  b.prop(
    (x) => x.value,
    (b) => {
      b.invalid((x) => root.onlyDigits && !/^\d*$/.test(x), 'Только цифры');
    },
  );
});

interface LostfocusValidationDemoState {
  data: Data;
}
export default class LostfocusValidationDemo extends React.Component {
  public state: LostfocusValidationDemoState = {
    data: {
      onlyDigits: false,
      value: '',
    },
  };

  public render() {
    const v = validate(this.state.data);
    return (
      <ValidationContainer>
        <Form>
          <Form.Line title="Только цифры">
            <Toggle
              checked={this.state.data.onlyDigits}
              onValueChange={(onlyDigits) => this.handleChange({ onlyDigits })}
            />
          </Form.Line>
          <Form.Line title="Значение">
            <ValidationWrapper validationInfo={v.getNode((x) => x.value).get()}>
              <Input
                placeholder={
                  this.state.data.onlyDigits ? 'Только цифры' : 'Любые символы'
                }
                value={this.state.data.value}
                onValueChange={(value) => this.handleChange({ value })}
              />
            </ValidationWrapper>
          </Form.Line>
        </Form>
      </ValidationContainer>
    );
  }

  private handleChange = (data: Partial<Data>) => {
    this.setState({ data: { ...this.state.data, ...data } });
  };
}
```
