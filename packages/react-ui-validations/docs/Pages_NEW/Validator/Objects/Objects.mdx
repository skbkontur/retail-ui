import { Meta, Canvas } from '@storybook/blocks';
import * as DocsStories from './Objects.docs.stories.tsx';

<Meta of={DocsStories} />

# Валидация объектов

Контракт валидируемой фомы может состоять из нескольких полей, иметь вложенные объекты и массивы.
У одного поля может быть несколько валидаций, а сами валидации могут зависеть от нескольких полей.
В таких случаях описание валидаций может стать громоздким и трудно поддерживаемым.

Validator позволяет декларативно описать все валидации на модели.
Гарантирует правильный порядок их выполнения.
Описание наглядно, а код типизирован.

## Плоский объект

### Описание правил валидаций

```jsx static
    interface ContactInfo {
      name: string;
      email: string;
    }

    const validate = createValidator<ContactInfo>(b => {
      b.prop(x => x.name, b => {
        b.invalid(x => !x, "Укажите имя", "submit");
      });
      b.prop(x => x.email, b => {
        b.invalid(x => !x, "Укажите email", "submit");
        b.invalid(x => !x.includes('@'), "Неверный формат email");
      });
    });
```

Метод `createValidator` создает функцию валидации контракта данных указанного типа.

```jsx static
const validate =
  createValidator <
  ContactInfo >
  ((b) => {
    //...
  });
```

Метод `prop` прогружается до нужного узла контракта.

```jsx static
b.prop(
  (x) => x.name,
  (b) => {
    //...
  },
);
```

Метод `invalid` задает критерий невалидности для узла, сообщение об ошибке, тип валидации, уровень валидации и её независимость.

```jsx static
b.invalid((x) => !x, 'Укажите имя', 'submit', 'warning', true);
```

Вместо типа валидации можно передать объект `InvalidValidationInfo`, где все свойства необязательные:

```jsx static
    interface InvalidValidationInfo {
      type?: Nullable<ValidationBehaviour>;
      level?: Nullable<ValidationLevel>;
      independent?: boolean;
    }

    b.invalid(x => !x, "Укажите имя", { independent: true });
```

Можно задать несколько критериев на один узел контракта.
Критерии применяются последовательно до первого сработавшего.

```jsx static
b.prop(
  (x) => x.email,
  (b) => {
    b.invalid((x) => !x, 'Укажите email', 'submit');
    b.invalid((x) => !x.includes('@'), 'Неверный формат email');
  },
);
```

### Получение объектов валидаций

Функция `validate` возвращает дерево валидаций по контракту данных.

```jsx static
const validation = validate(contactInfo);
```

Метод `getNode` прогружается до конкретного узла дерева, а метод `get` возвращает объект валидации узла.

```jsx static
const validationInfo = validation.getNode((x) => x.name).get();
```

Объект валидации `validationInfo` можно передать в проп компонента `ValidationWrapper`.

```jsx static
<ValidationWrapper validationInfo={validationInfo}>
  <Input />
</ValidationWrapper>
```

### Пример

<Canvas of={DocsStories.FlatObject} />

```jsx static
import React from 'react';
import { Button } from '@skbkontur/react-ui/components/Button';
import { Input } from '@skbkontur/react-ui/components/Input';

import { createValidator, ValidationContainer, ValidationWrapper } from '../../../../src';
import { Nullable } from '../../../../typings/Types';
import { Form } from '../../../Common/Form';

interface ContactInfo {
  name: string;
  email: string;
}

const validate = createValidator<ContactInfo>((b) => {
  b.prop(
    (x) => x.name,
    (b) => {
      b.invalid((x) => !x, 'Укажите имя', 'submit');
    },
  );
  b.prop(
    (x) => x.email,
    (b) => {
      b.invalid((x) => !x, 'Укажите email', 'submit');
      b.invalid((x) => !x.includes('@'), 'Неверный формат email');
    },
  );
});

interface FlatObjectDemoState {
  contactInfo: ContactInfo;
}
export default class FlatObjectDemo extends React.Component {
  public state: FlatObjectDemoState = {
    contactInfo: {
      name: '',
      email: '',
    },
  };

  private container: Nullable<ValidationContainer> = null;

  public render() {
    const { contactInfo } = this.state;
    const validation = validate(contactInfo);
    return (
      <ValidationContainer ref={this.refContainer}>
        <Form>
          <Form.Line title="Имя">
            <ValidationWrapper validationInfo={validation.getNode((x) => x.name).get()}>
              <Input
                placeholder={'Любое'}
                value={contactInfo.name}
                onValueChange={(name) => this.handleChange({ name })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.Line title="E-mail">
            <ValidationWrapper validationInfo={validation.getNode((x) => x.email).get()}>
              <Input
                placeholder={'xxx@xxx.xx'}
                value={contactInfo.email}
                onValueChange={(email) => this.handleChange({ email })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.ActionsBar>
            <Button use={'primary'} onClick={this.handleSubmit}>
              Submit
            </Button>
          </Form.ActionsBar>
        </Form>
      </ValidationContainer>
    );
  }

  private handleChange = (value: Partial<ContactInfo>): void => {
    this.setState({ contactInfo: { ...this.state.contactInfo, ...value } });
  };

  private handleSubmit = async (): Promise<void> => {
    if (!this.container) {
      throw new Error('invalid state');
    }
    if (await this.container.validate()) {
      alert('success');
    }
  };

  private refContainer = (el: Nullable<ValidationContainer>) => (this.container = el);
}
```

## Примитивный тип

Валидация данных примитивного типа является вырожденным случаем.
При описании и чтении валидации не потребуется прогрузка до вложенных полей.

```jsx static
const validateEmail =
  createValidator <
  string >
  ((b) => {
    b.invalid((x) => !x, 'Укажите email', 'submit');
    b.invalid((x) => !x.includes('@'), 'Неверный формат email');
  });
```

Объект валидации извлекается из корневого узла дерева валидаций.

```jsx static
const validation = validateEmail(email);
const validationInfo = validation.get();
```

### Пример

<Canvas of={DocsStories.PrimitiveType} />

```jsx static
import React from 'react';
import { Button } from '@skbkontur/react-ui/components/Button';
import { Input } from '@skbkontur/react-ui/components/Input';

import { ValidationContainer, ValidationWrapper, createValidator } from '../../../../src';
import { Nullable } from '../../../../typings/Types';
import { Form } from '../../../Common/Form';

interface PrimitiveTypeDemoState {
  email: string;
}

const validate = createValidator<string>((b) => {
  b.invalid((x) => !x, 'Укажите email', 'submit');
  b.invalid((x) => !x.includes('@'), 'Неверный формат email');
});

export default class PrimitiveTypeDemo extends React.Component {
  public state: PrimitiveTypeDemoState = {
    email: '',
  };

  private container: Nullable<ValidationContainer> = null;

  public render() {
    const validation = validate(this.state.email);
    return (
      <ValidationContainer ref={this.refContainer}>
        <Form>
          <Form.Line title="E-mail">
            <ValidationWrapper validationInfo={validation.get()}>
              <Input
                placeholder={'xxx@xxx.xx'}
                value={this.state.email}
                onValueChange={(email) => this.setState({ email })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.ActionsBar>
            <Button use={'primary'} onClick={this.handleSubmit}>
              Submit
            </Button>
          </Form.ActionsBar>
        </Form>
      </ValidationContainer>
    );
  }

  public handleSubmit = async (): Promise<void> => {
    if (!this.container) {
      throw new Error('invalid state');
    }
    if (await this.container.validate()) {
      alert('success');
    }
  };

  private refContainer = (el: Nullable<ValidationContainer>) => (this.container = el);
}
```

## Объект со вложенностью

Для валидации контракта данных со вложенным объектами используются вложенные прогрузки с помощью метода `prop`.

```jsx static
    interface FullName {
      surname: string;
      name: string;
    }

    interface ContactInfo {
      fullName: FullName;
      email: string;
    }

    const validateContact = createValidator<ContactInfo>(b => {
      b.prop(x => x.fullName, b => {
        b.prop(x => x.name, b => {
          b.invalid(x => !x, "Укажите имя", "submit");
        });
        b.prop(x => x.surname, b => {
          b.invalid(x => !x, "Укажите фамилию", "submit");
        });
      });
      b.prop(x => x.email, b => {
        b.invalid(x => !x, "Укажите email", "submit");
        b.invalid(x => !x.includes('@'), "Неверный формат email");
      });
    });
```

Чтение объекта валидации осуществляется через прогрузку до узла методом `getNode`.

```jsx static
const validation = validateContact(contactInfo);
const fullNameNode = validation.getNode((x) => x.fullName);
const nameNode = fullNameNode.getNode((x) => x.name);
const validationInfo = nameNode.get();
```

Прогрузку до узла можно записать одним выражением.

```jsx static
const validation = validateContact(contactInfo);
const validationInfo = validation.getNode((x) => x.fullName.name).get();
```

### Пример

<Canvas of={DocsStories.NestedObject} />

```jsx static
import React from 'react';
import { Button } from '@skbkontur/react-ui/components/Button';
import { Input } from '@skbkontur/react-ui/components/Input';

import { ValidationContainer, ValidationWrapper, createValidator } from '../../../../src';
import { Nullable } from '../../../../typings/Types';
import { Form } from '../../../Common/Form';

interface FullName {
  surname: string;
  name: string;
}

interface ContactInfo {
  fullName: FullName;
  email: string;
}

const validate = createValidator<ContactInfo>((b) => {
  b.prop(
    (x) => x.fullName,
    (b) => {
      b.prop(
        (x) => x.name,
        (b) => {
          b.invalid((x) => !x, 'Укажите имя', 'submit');
        },
      );
      b.prop(
        (x) => x.surname,
        (b) => {
          b.invalid((x) => !x, 'Укажите фамилию', 'submit');
        },
      );
    },
  );
  b.prop(
    (x) => x.email,
    (b) => {
      b.invalid((x) => !x, 'Укажите email', 'submit');
      b.invalid((x) => !x.includes('@'), 'Неверный формат email');
    },
  );
});

interface NestedObjectDemoState {
  contactInfo: ContactInfo;
}
export default class NestedObjectDemo extends React.Component {
  public state: NestedObjectDemoState = {
    contactInfo: {
      fullName: {
        name: '',
        surname: '',
      },
      email: '',
    },
  };

  private container: Nullable<ValidationContainer> = null;

  public render() {
    const { contactInfo } = this.state;
    const v = validate(contactInfo);
    return (
      <ValidationContainer ref={this.refContainer}>
        <Form>
          <Form.Line title="Имя">
            <ValidationWrapper validationInfo={v.getNode((x) => x.fullName.name).get()}>
              <Input
                placeholder={'Любое'}
                value={contactInfo.fullName.name}
                onValueChange={(name) => this.handleFullNameChange({ name })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.Line title="Фамилия">
            <ValidationWrapper
              validationInfo={v.getNode((x) => x.fullName.surname).get()}
            >
              <Input
                placeholder={'Любая'}
                value={contactInfo.fullName.surname}
                onValueChange={(surname) => this.handleFullNameChange({ surname })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.Line title="E-mail">
            <ValidationWrapper validationInfo={v.getNode((x) => x.email).get()}>
              <Input
                placeholder={'xxx@xxx.xx'}
                value={contactInfo.email}
                onValueChange={(email) => this.handleChange({ email })}
              />
            </ValidationWrapper>
          </Form.Line>

          <Form.ActionsBar>
            <Button use={'primary'} onClick={this.handleSubmit}>
              Submit
            </Button>
          </Form.ActionsBar>
        </Form>
      </ValidationContainer>
    );
  }

  private handleFullNameChange = (value: Partial<FullName>): void => {
    this.handleChange({ fullName: { ...this.state.contactInfo.fullName, ...value } });
  };

  private handleChange = (value: Partial<ContactInfo>): void => {
    this.setState({ contactInfo: { ...this.state.contactInfo, ...value } });
  };

  private handleSubmit = async (): Promise<void> => {
    if (!this.container) {
      throw new Error('invalid state');
    }
    if (await this.container.validate()) {
      alert('success');
    }
  };

  private refContainer = (el: Nullable<ValidationContainer>) => (this.container = el);
}
```
