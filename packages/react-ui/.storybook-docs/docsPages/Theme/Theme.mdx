import { Markdown, Story } from '@storybook/blocks';

import { Meta } from '../../Meta';

import * as ThemeStories from './Theme.docs.stories';
import { linkTo } from '@storybook/addon-links';
import { Link } from '@skbkontur/react-ui/components/Link';

<Meta of={ThemeStories} />

# Theme

Темы в React UI позволяют переключаться между светлой и темной темами, а также кастомизировать внешний вид компонентов.
Например, для гибкой настройки цветов, размеров, отступов, теней и др. параметров.

<br />

<Link onClick={linkTo('Information/ThemePlayground')} style={{ fontSize: 20 }}>
  <b>Playground со всеми переменными →</b>
</Link>

<br />
<br />
<br />

---

<br />

Для кастомизации компонентов используется `<ThemeContext>`. Динамические стили генерируются в зависимости от темы в процессе render'а с помощью <a href="https://www.npmjs.com/package/@emotion/css" target="_blank">@emotion/css</a>, полученные классы добавляются в `className` соответствующих элементов.

Тема задается с помощью `<ThemeContext.Provider>`:

```jsx static
import { ThemeContext } from '@skbkontur/react-ui';
import { DARK_THEME } from '@skbkontur/react-ui/lib/theming/themes/DarkTheme';

<ThemeContext.Provider value={DARK_THEME}>{/* ... */}</ThemeContext.Provider>;
```

Объект со значениями темы доступен через `<ThemeContext.Consumer>`:

```jsx static
import { ThemeContext, Button } from '@skbkontur/react-ui';

<ThemeContext.Consumer>
  {theme => /* ... */ }
</ThemeContext.Consumer>
```

В функцониальных компонентах применяется хук `useContext`

```typescript static
const theme = useContext(ThemeContext);
```

В классовых компонентах объект с темой доступен через `contextType`

```typescript static
public static contextType = ThemeContext;
public context: Theme = this.context;
```

## Создание/редактирование темы

Кастомные значения нужно передать в `ThemeFactory.create` и получившуюся тему можно использовать в `ThemeContext.Provider`. `ThemeFactory` расширяет переданный объект, задавая в качестве прототипа объект темы по умолчанию.

<Story of={ThemeStories.Example1} />

Вторым аргументом `ThemeFactory.create` может принимать объект, который будет использован в качестве базовой темы.

```jsx static
import { ThemeFactory, LIGHT_THEME } from '@skbkontur/react-ui';

const myFlatTheme = ThemeFactory.create({ btnBorderRadiusSmall: '10px' }, LIGHT_THEME);
```

## Использование переменных из темы

<Story of={ThemeStories.Example2} />

## Добавление своих переменных

Для дополнения существующей темы новыми переменными для своих компонентов, можно создать отдельный контекст с расширенным объектом темы

<Story of={ThemeStories.Example3} />

## Кастомизация legacy-приложений

В случае, если контролы рендерятся через какую-то общую обертку, достаточно добавить в нее `ThemeContext.Provider` с вашей темой. В противном случае, вам подойдет метод `ThemeFactory.overrideDefaultTheme()`.

```typescript static
import theme from './theme/theme';
import { ThemeFactory } from '@skbkontur/react-ui/lib/theming/ThemeFactory';

ThemeFactory.overrideDefaultTheme(theme);
```

## Вложенные темы

<Story of={ThemeStories.Example5} />

## Несколько тем вместе

```jsx harmony
import { ThemeContext, LIGHT_THEME, DARK_THEME } from '@skbkontur/react-ui';
import { ShowcaseGroup } from '@skbkontur/react-ui/internal/ThemePlayground/ShowcaseGroup';

const CombinedComponents = () => (
  <>
    <div style={{ height: '100%', background: '#fff', padding: '16px' }}>
      <ThemeContext.Provider value={LIGHT_THEME}>
        <div>
          <ShowcaseGroup title="LIGHT_THEME" />
        </div>
      </ThemeContext.Provider>
    </div>
    <div style={{ height: '100%', background: '#000', padding: '16px' }}>
      <ThemeContext.Provider value={DARK_THEME}>
        <div>
          <ShowcaseGroup title="DARK_THEME" />
        </div>
      </ThemeContext.Provider>
    </div>
  </>
);

<CombinedComponents />;
```

## Темы @skbkontur/react-ui-addons

Компоненты `@skbkontur/react-ui-addons` так же поддерживают кастомизацию через `ThemeContext` из `@skbkontur/react-ui`. Достаточно переопределить нужные переменные, которые перечислены на страницах компонентов в [докумендации аддонов](https://ui.gitlab-pages.kontur.host/docs/#/react-ui-addons).

```tsx static
import { ThemeContext, ThemeFactory } from '@skbkontur/react-ui';
import { Logotype, AddonsThemeIn } from '@skbkontur/react-ui-addons';

const myTheme = ThemeFactory.create<AddonsThemeIn>({
  logoColor: 'black',
});

<ThemeContext.Provider value={myTheme}>
  <Logotype />
</ThemeContext.Provider>;
```

## Дополнительно: утилиты для цветов и размеров

В библиотеке есть несколько утилит для работы с цветами при создании своих тем

```typescript static
import { ColorFunctions } from '@skbkontur/react-ui'

ColorFunctions.lighten(colorString: string, amount: number | string, method?: 'absolute' | 'relative'): string
ColorFunctions.darken(colorString: string, amount: number | string, method?: 'absolute' | 'relative'): string
ColorFunctions.contrast(colorString: string, darkString?: string, lightString?: string, threshold: number = 0.43): string
ColorFunctions.red(colorString: string): string
ColorFunctions.green(colorString: string): string
ColorFunctions.blue(colorString: string): string
ColorFunctions.alpha(colorString: string): string
ColorFunctions.isValid(colorString: string): boolean // проверяет, можно ли распарсить строку в цвет
```

Документацию по их работе можно найти на сайте [less](http://lesscss.org/functions/#color-operations).
В качестве colorString можно передать цвет в одном из форматов: `keyword`, `hex`, `rgb(r, g, b)`, `rgba(r, g, b, a)`, `hsl(h, s, l)`, `hsla(h, s, l, a)`.
В качестве `amount` можно передать строку вида 'N%' или число от 0 до 1.
Все значения больше или меньше возможных обрезаются. Например, для `rgba(300, -100, 123, 20)` `r=255, g=0, b=123, a=1`.
Если распарсить `colorString` не получилось - выбрасывается исключение.
Если это возможно, результат возвращается в том же виде, что и входная строка:

```typescript static
import { ColorFunctions } from '@skbkontur/react-ui';

ColorFunctions.lighten('hsl(90, 0.8, 0.2)', '20%') === 'hsl(90, 0.8, 0.4)';
ColorFunctions.lighten('rgba(50, 50, 50, 0.2)', '20%') === 'rgba(102, 102, 102, 0.2)';
ColorFunctions.lighten('#80e619', 0.2) === '#b3f075';
ColorFunctions.lighten('crimson', '20%') === '#f16581';
```

Для работы с размерами предусмотрена одна функция (_DimensionFunctions.ts_):

```typescript static
shift(value: string, shift: string): string

// пример
import { DimensionFunctions } from '@skbkontur/react-ui'

DimensionFunctions.shift('100%', '-20') === '80%'
DimensionFunctions.shift('2em', '+2') === '4em'
DimensionFunctions.shift('12', '+1') === '13px'  //если единица измерения не указана - используется px
DimensionFunctions.shift('10.2', '12.333451') === '22.5335px' //дробная часть округляется до 4 знаков
```

## Версии тем

С версии 5.0 в библиотеке появилось версионирование тем для облегчения обновления библиотеки. Версии тем позволяют <b>откатывать визуальные изменения</b> компоенентов к предыдущим минорным версиям, <b>отложив их на будущее</b>.

Помимо `LIGHT_THEME` и `DARK_THEME` с актуальным фирменным стилем, в пакете содержатся темы с фиксированными минорными версиями (например, `LIGHT_THEME_5_1` или `DARK_THEME_5_2`).

```
import { ThemeContext } from '@skbkontur/react-ui/lib/theming/ThemeContext';
import { LIGHT_THEME, LIGHT_THEME_5_2 } from '@skbkontur/react-ui/lib/theming/themes/LightTheme';

// Тема последней версии библиотеки
<ThemeContext.Provider value={LIGHT_THEME}>
  {/* ... */}
</ThemeContext.Provider>

// Тема фиксированной версии библиотеки 5.2
<ThemeContext.Provider value={LIGHT_THEME_5_2}>
  {/* ... */}
</ThemeContext.Provider>
```

<Story of={ThemeStories.ThemesList} />

⚠️ Вы можете использовать промежуточную версию темы неограниченно долго в рамках одной мажорной версии библиотеки. Однако, в момент выхода новой мажорной версии, все предыдущие промежуточные версии тем из нее удаляются. Это значит, что при миграции на новую мажорную версию, придется применить все отложенные визуальные изменения.

<details>
<summary>Подробнее о версиях</summary>

Представим, что текущая версия библиотеки пользователя: `5.5.0`. Он решает обновить библиотеку до `5.10.0`, в которой есть визуальные изменения по сравнению с его текущей темой, но которые он пока не хочет применять. При этом, он не пользовался версионированием тем до этого момента, используя просто `LIGHT_THEME`. В версии `5.10.0` набор тем может выглядеть примерно так:

- LIGHT_THEME
- LIGHT_THEME_5_0
- LIGHT_THEME_5_4
- LIGHT_THEME_5_8
- LIGHT_THEME_5_10

Чтобы исключить все визуальные изменения, которых у пользователя нет на момент обновления, ему следует выбрать версию темы, наиболее близкую, но не превышающую ту, что он использовал до обновления. Т.е. на момент использования им версии `5.5.0` и дефолтной `LIGHT_THEME` внутри нее, он по факту использует `LIGHT_THEME_5_4`. И ему следует переключиться именно на нее, чтобы отложить применение визуальных изменений после обновления на `5.10.0`.

</details>
